/*
 * Copyright (C) 2013-2017, Shenzhen Huiding Technology Co., Ltd.
 * All Rights Reserved.
 * Version:
 * Description:
 * History:
 */

#ifndef _GF_ERROR_H_
#define _GF_ERROR_H_

#include <stdint.h>

#ifdef __cplusplus
extern "C"
{
#endif  // #ifdef __cplusplus

#define GF_ERROR_BREAK(err)  { if (GF_SUCCESS != (err)) { break; } }

typedef enum gf_error
{
    GF_SUCCESS = 0,

    // ta error
    GF_ERROR_BASE = 1000,
    GF_ERROR_OUT_OF_MEMORY,  // = GF_ERROR_BASE + 1,
    GF_ERROR_OPEN_TA_FAILED,  // = GF_ERROR_BASE + 2,
    GF_ERROR_BAD_PARAMS,  // = GF_ERROR_BASE + 3,
    GF_ERROR_NO_SPACE,  // = GF_ERROR_BASE + 4,
    GF_ERROR_REACH_FINGERS_UPLIMIT,  // = GF_ERROR_BASE + 5,
    GF_ERROR_NOT_MATCH,  // = GF_ERROR_BASE + 6,
    GF_ERROR_CANCELED,  // = GF_ERROR_BASE + 7,
    GF_ERROR_TIMEOUT,  // = GF_ERROR_BASE + 8,
    GF_ERROR_PREPROCESS_FAILED,  // = GF_ERROR_BASE + 9,
    GF_ERROR_GENERIC,  // = GF_ERROR_BASE + 10,
    GF_ERROR_ACQUIRED_PARTIAL,  // = GF_ERROR_BASE + 11,
    GF_ERROR_ACQUIRED_IMAGER_DIRTY,  // = GF_ERROR_BASE + 12,
    GF_ERROR_DUPLICATE_FINGER,  // = GF_ERROR_BASE + 13,
    GF_ERROR_OPEN_DEVICE_FAILED,  // = GF_ERROR_BASE + 14,
    GF_ERROR_HAL_GENERAL_ERROR,  // = GF_ERROR_BASE + 15,
    GF_ERROR_HAL_FILE_DESCRIPTION_NULL,  // = GF_ERROR_BASE + 16,
    GF_ERROR_HAL_IOCTL_FAILED,  // = GF_ERROR_BASE + 17,
    GF_ERROR_HAL_TIMER_FUNC,  // = GF_ERROR_BASE + 18,
    GF_ERROR_CORRUPT_CONTENT,  // = GF_ERROR_BASE + 19,
    GF_ERROR_INCORRECT_VERSION,  // = GF_ERROR_BASE + 20,
    GF_ERROR_CORRUPT_OBJECT,  // = GF_ERROR_BASE + 21,
    GF_ERROR_INVALID_DATA,  // = GF_ERROR_BASE + 22,
    GF_ERROR_SPI_TRANSFER_ERROR,  // = GF_ERROR_BASE + 23,
    GF_ERROR_SPI_GENERAL_ERROR,  // = GF_ERROR_BASE + 24,
    GF_ERROR_SPI_IRQ_HANDLE,  // = GF_ERROR_BASE + 25,
    GF_ERROR_SPI_RAW_DATA_CRC_FAILED,  // = GF_ERROR_BASE + 26,
    GF_ERROR_SPI_RAW_DATA_BUF_BUSY,  // = GF_ERROR_BASE + 27,
    GF_ERROR_SPI_FW_CFG_DATA_ERROR,  // = GF_ERROR_BASE + 28,
    GF_ERROR_SPI_FW_DOWNLOAD_FAILED,  // = GF_ERROR_BASE + 29,
    GF_ERROR_SPI_CFG_DOWNLOAD_FAILED,  // = GF_ERROR_BASE + 30,
    GF_ERROR_SAVE_FP_TEMPLATE,  // = GF_ERROR_BASE + 31,
    GF_ERROR_FP_BUSY,  // = GF_ERROR_BASE + 32,
    GF_ERROR_OPEN_SECURE_OBJECT_FAILED,  // = GF_ERROR_BASE + 33,
    GF_ERROR_READ_SECURE_OBJECT_FAILED,  // = GF_ERROR_BASE + 34,
    GF_ERROR_WRITE_SECURE_OBJECT_FAILED,  // = GF_ERROR_BASE + 35,
    GF_ERROR_DELETE_SECURE_OBJECT_FAILED,  // = GF_ERROR_BASE + 36,
    GF_ERROR_SECURE_OBJECT_NOT_EXIST,  // = GF_ERROR_BASE + 37,
    GF_ERROR_WRITE_CONFIG_FAILED,  // = GF_ERROR_BASE + 38,
    GF_ERROR_TEST_SENSOR_FAILED,  // = GF_ERROR_BASE + 39,
    GF_ERROR_SET_MODE_FAILED,  // = GF_ERROR_BASE + 40,
    GF_ERROR_CHIP_ID_NOT_CORRECT,  // = GF_ERROR_BASE + 41,
    GF_ERROR_MAX_NUM,  // = GF_ERROR_BASE + 42,
    GF_ERROR_TEST_BAD_POINT_FAILED,  // = GF_ERROR_BASE + 43,
    GF_ERROR_TEST_FRR_FAR_ENROLL_DIFFERENT_FINGER,  // = GF_ERROR_BASE + 44,
    GF_ERROR_DUPLICATE_AREA,  // = GF_ERROR_BASE + 45,
    GF_ERROR_SPI_COMMUNICATION,  // = GF_ERROR_BASE + 46,
    GF_ERROR_FINGER_NOT_EXIST,  // = GF_ERROR_BASE + 47,
    // This means the saved preprocess version is
    GF_ERROR_INVALID_PREPROCESS_VERSION,  // = GF_ERROR_BASE + 48,

    // different from the new preprocess version.
    // Should delete the saved calibration parameters.
    GF_ERROR_TA_DEAD,  // = GF_ERROR_BASE + 49,
    GF_ERROR_NAV_TOO_FAST,  // = GF_ERROR_BASE + 50,
    GF_ERROR_UNSUPPORT_CHIP,  // = GF_ERROR_BASE + 51,
    // Means that finger press event is caused by temperature, should update all base
    GF_ERROR_INVALID_FINGER_PRESS,  // = GF_ERROR_BASE + 52,
    GF_ERROR_TA_GENERATE_RANDOM,  // = GF_ERROR_BASE + 53,
    GF_ERROR_BIO_ASSAY_FAIL,  // = GF_ERROR_BASE + 54,
    GF_ERROR_INVALID_HAT_VERSION,  // = GF_ERROR_BASE + 55,
    GF_ERROR_INVALID_CHALLENGE,  // = GF_ERROR_BASE + 56,
    GF_ERROR_UNTRUSTED_ENROLL,  // = GF_ERROR_BASE + 57,
    GF_ERROR_INVALID_BASE,  // = GF_ERROR_BASE + 58,

    GF_ERROR_SENSOR_BROKEN_CHECK_NEXT_FRAME,  // = GF_ERROR_BASE + 59,
    GF_ERROR_SENSOR_BROKEN_CHECK_ALGO_ERROR,  // = GF_ERROR_BASE + 60,
    GF_ERROR_SENSOR_IS_BROKEN,  // = GF_ERROR_BASE + 61,
    GF_ERROR_SENSOR_NOT_AVAILABLE,  // = GF_ERROR_BASE + 62,

    // sensor test failed (check sensor otp info)
    GF_ERROR_SENSOR_TEST_FAILED,  // = GF_ERROR_BASE + 63,

    // Authenticate fail,then re-sampling image and re-authenticate.
    GF_ERROR_MATCH_FAIL_AND_RETRY,  // = GF_ERROR_BASE + 64,

    GF_ERROR_FINGER_NOT_LEAVE,  // = GF_ERROR_BASE + 65,  // Finger is not leave
    GF_ERROR_GET_TEMPERATURE_FAILED,  // = GF_ERROR_BASE + 66,
    GF_ERROR_GET_OTP_INFO_FAILED,  // = GF_ERROR_BASE + 67,
    GF_ERROR_TEST_RESET_PIN,  // = GF_ERROR_BASE + 68,
    GF_ERROR_TEST_INTERRUPT_PIN,  // = GF_ERROR_BASE + 69,
    GF_ERROR_UNKNOWN_CMD,  // = GF_ERROR_BASE + 70,

    // test spi transfer
    GF_ERROR_TEST_SPI_TRANSFER_TIMEOUT,  // = GF_ERROR_BASE + 71,

    // fido error code
    GF_ERROR_ENCODE_TLV,  // = GF_ERROR_BASE + 72,
    GF_ERROR_INVALID_FP_ID,  // = GF_ERROR_BASE + 73,

    // native service errors
    GF_ERROR_NATIVE_SERVICE_BASE,  // = GF_ERROR_BASE + 74,
    GF_ERROR_NATIVE_SERVICE_GETSERVICE,  // = GF_ERROR_BASE + 75,
    GF_ERROR_NATIVE_SERVICE_INIT_HAL,  // = GF_ERROR_BASE + 76,

    GF_ERROR_MKDIR_FAILED,  // = GF_ERROR_BASE + 77,
    GF_ERROR_FILE_OPEN_FAILED,  // = GF_ERROR_BASE + 78,
    GF_ERROR_FILE_NOT_EXIST,  // = GF_ERROR_BASE + 79,

    GF_ERROR_FILE_READ_FAILED,  // = GF_ERROR_BASE + 80,
    GF_ERROR_FILE_WRITE_FAILED,  // = GF_ERROR_BASE + 81,
    GF_ERROR_FILE_DELETE_FAILED,  // = GF_ERROR_BASE + 82,

    // rawdata saturated error
    GF_ERROR_TOO_MUCH_UNDER_SATURATED_PIXELS,  // = GF_ERROR_BASE + 83,
    GF_ERROR_TOO_MUCH_OVER_SATURATED_PIXELS,  // = GF_ERROR_BASE + 84,

    GF_ERROR_SENSOR_HAS_CHANGED,  // = GF_ERROR_BASE + 85,

    GF_ERROR_OPEN_SESSION_FAILED,  // = GF_ERROR_BASE + 86,

    GF_ERROR_FACTORY_TEST_FAILED,  // = GF_ERROR_BASE + 87,

    GF_ERROR_NO_GROUP_ID,  // = GF_ERROR_BASE + 88,

    GF_ERROR_UNKNOWN_TEST_TOKEN,  // = GF_ERROR_BASE + 89,

    GF_FINGER_FEATURE_STUDY_FAILED,  // = GF_ERROR_BASE + 90,

    GF_ERROR_INVALID_OTP_VERSION,  // = GF_ERROR_BASE + 91,

    GF_ERROR_CALIBRATION_NOT_READY,  // = GF_ERROR_BASE + 92,

    GF_ERROR_ALGO_INVALID_DATA,  // = GF_ERROR_BASE + 93,
    GF_ERROR_TOO_FAST,  // = GF_ERROR_BASE + 94,
    GF_ERROR_TEST_NOT_SUPPORTED,  // = GF_ERROR_BASE + 95,
    GF_ERROR_NO_NEED_UPDATE_BASE,  // = GF_ERROR_BASE + 96,
    GF_ERROR_OTP_CHECK_FAIL,  // = GF_ERROR_BASE+97,

    GF_ERROR_INIT_ALGO_REGISTER_INFO,  // = GF_ERROR_BASE + 98,
    GF_ERROR_DYNAMIC_ENROLL_INVALID_PRESS_TOO_MUCH,  // = GF_ERROR_BASE + 99,
    GF_ERROR_DYNAMIC_ERNOLL_INCOMPLETE_TEMPLATE,  // = GF_ERROR_BASE + 100,

    GF_ERROR_ALGO_DIRTY_FINGER,  // GF_ERROR_BASE + 101

    GF_ERROR_PREPROCESS_FAIL_AND_RETRY,  // = GF_ERROR_BASE + 102,
    GF_ERROR_CRC_CHECK_FAILED_AND_RETRY,  // = GF_ERROR_BASE + 103,

    GF_ERROR_ALGO_COVER_BROKEN,  // = GF_ERROR_BASE + 104,
    GF_ERROR_SENSOR_ID_NOT_CHANGED,  // = GF_ERROR_BASE + 105,
    GF_ERROR_FARGO_CHIP_ID_NOT_CORRECT,  //= GF_ERROR_BASE + 106,
    GF_ERROR_NEED_RESET,  // = GF_ERROR_BASE + 107,
    GF_ERROR_WRONG_REG_VALUE,  // = GF_ERROR_BASE + 108,
    GF_ERROR_FARGO_INIT_CONFIG_FAILED,  // = GF_ERROR_BASE + 109,
    GF_ERROR_ALGO_PALM_DETECT,  // = GF_ERROR_BASE + 110,

    GF_ERROR_FDT_RET_BAD,  // = GF_ERROR_BASE + 111,
    GF_ERROR_FDT_RET_BASE_BAD,  // = GF_ERROR_BASE + 112,
    GF_ERROR_FDT_RET_CUR_BAD,  // = GF_ERROR_BASE + 113,
    GF_ERROR_FDT_RET_TEMP,  // = GF_ERROR_BASE + 114,
    GF_ERROR_FDT_RET_VOID,  // = GF_ERROR_BASE + 115,
    GF_ERROR_FDT_RET_FOREIGN,  // = GF_ERROR_BASE + 116,
    GF_ERROR_TOO_SLOW,  //  = GF_ERROR_BASE + 117,
    GF_ERROR_OVER_CURRENT,  // = GF_ERROR_BASE + 118,
    GF_ERROR_ALGO_FAKE,  // = GF_ERROR_BASE + 119,
    GF_ERROR_ENROLL_TIMEOUT, // = GF_ERROR_BASE + 120, FOR OPPO
    GF_ERROR_MAX,  // = GF_ERROR_BASE + 120,
} gf_error_t;

typedef struct
{
    gf_error_t err;
    const char *strerror;
} gf_strerror_t;

extern gf_strerror_t err_table[ ];

const char *gf_strerror(const gf_error_t err);

uint32_t gf_get_err_table_len(void);

#ifdef __cplusplus
}
#endif  // #ifdef __cplusplus

#endif      // _GF_ERROR_H_
